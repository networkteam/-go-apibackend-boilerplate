// Code generated by https://github.com/src-d/go-kallax. DO NOT EDIT.
// Please, do not touch the code below, and if you do, do it under your own
// risk. Take into account that all the code you write here will be completely
// erased from earth the next time you generate the kallax models.
package records

import (
	"database/sql"
	"fmt"
	"time"

	"github.com/zbyte/go-kallax"
	"github.com/zbyte/go-kallax/types"
)

var _ types.SQLType
var _ fmt.Formatter

type modelSaveFunc func(*kallax.Store) error

// NewAccount returns a new instance of Account.
func NewAccount() (record *Account, err error) {
	return newAccount()
}

// GetID returns the primary key of the model.
func (r *Account) GetID() kallax.Identifier {
	return (*kallax.UUID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Account) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.UUID)(&r.ID), nil
	case "type":
		return &r.Type, nil
	case "role_identifier":
		return &r.RoleIdentifier, nil
	case "first_name":
		return types.Nullable(&r.FirstName), nil
	case "last_name":
		return types.Nullable(&r.LastName), nil
	case "secret":
		return types.Slice(&r.Secret), nil
	case "email_address":
		return types.Nullable(&r.EmailAddress), nil
	case "password_hash":
		return types.Slice(&r.PasswordHash), nil
	case "device_token":
		return types.Nullable(&r.DeviceToken), nil
	case "device_os":
		return types.Nullable(&r.DeviceOs), nil
	case "organisation_id":
		if r.OrganisationID == nil {
			r.OrganisationID = new(kallax.UUID)
		}
		return types.Nullable(r.OrganisationID), nil
	case "device_label":
		return types.Nullable(&r.DeviceLabel), nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Account: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Account) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "type":
		return r.Type, nil
	case "role_identifier":
		return r.RoleIdentifier, nil
	case "first_name":
		if r.FirstName == (*string)(nil) {
			return nil, nil
		}
		return r.FirstName, nil
	case "last_name":
		if r.LastName == (*string)(nil) {
			return nil, nil
		}
		return r.LastName, nil
	case "secret":
		return types.Slice(r.Secret), nil
	case "email_address":
		if r.EmailAddress == (*string)(nil) {
			return nil, nil
		}
		return r.EmailAddress, nil
	case "password_hash":
		return types.Slice(r.PasswordHash), nil
	case "device_token":
		if r.DeviceToken == (*string)(nil) {
			return nil, nil
		}
		return r.DeviceToken, nil
	case "device_os":
		if r.DeviceOs == (*string)(nil) {
			return nil, nil
		}
		return r.DeviceOs, nil
	case "organisation_id":
		if r.OrganisationID == (*kallax.UUID)(nil) {
			return nil, nil
		}
		return r.OrganisationID, nil
	case "device_label":
		if r.DeviceLabel == (*string)(nil) {
			return nil, nil
		}
		return r.DeviceLabel, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Account: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Account) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Account has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Account) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Account has no relationships")
}

// AccountStore is the entity to access the records of the type Account
// in the database.
type AccountStore struct {
	*kallax.Store
}

// NewAccountStore creates a new instance of AccountStore
// using a SQL database.
func NewAccountStore(db *sql.DB) *AccountStore {
	return &AccountStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *AccountStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *AccountStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *AccountStore) Debug() *AccountStore {
	return &AccountStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *AccountStore) DebugWith(logger kallax.LoggerFunc) *AccountStore {
	return &AccountStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *AccountStore) DisableCacher() *AccountStore {
	return &AccountStore{s.Store.DisableCacher()}
}

// Insert inserts a Account in the database. A non-persisted object is
// required for this operation.
func (s *AccountStore) Insert(record *Account) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return err
	}

	return s.Store.Insert(Schema.Account.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *AccountStore) Update(record *Account, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	if err := record.BeforeSave(); err != nil {
		return 0, err
	}

	return s.Store.Update(Schema.Account.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *AccountStore) Save(record *Account) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *AccountStore) Delete(record *Account) error {
	return s.Store.Delete(Schema.Account.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *AccountStore) Find(q *AccountQuery) (*AccountResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewAccountResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *AccountStore) MustFind(q *AccountQuery) *AccountResultSet {
	return NewAccountResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *AccountStore) Count(q *AccountQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *AccountStore) MustCount(q *AccountQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *AccountStore) FindOne(q *AccountQuery) (*Account, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *AccountStore) FindAll(q *AccountQuery) ([]*Account, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *AccountStore) MustFindOne(q *AccountQuery) *Account {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Account with the data in the database and
// makes it writable.
func (s *AccountStore) Reload(record *Account) error {
	return s.Store.Reload(Schema.Account.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *AccountStore) Transaction(callback func(*AccountStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&AccountStore{store})
	})
}

// AccountQuery is the object used to create queries for the Account
// entity.
type AccountQuery struct {
	*kallax.BaseQuery
}

// NewAccountQuery returns a new instance of AccountQuery.
func NewAccountQuery() *AccountQuery {
	return &AccountQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Account.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *AccountQuery) Select(columns ...kallax.SchemaField) *AccountQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *AccountQuery) SelectNot(columns ...kallax.SchemaField) *AccountQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *AccountQuery) Copy() *AccountQuery {
	return &AccountQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *AccountQuery) Order(cols ...kallax.ColumnOrder) *AccountQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *AccountQuery) BatchSize(size uint64) *AccountQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *AccountQuery) Limit(n uint64) *AccountQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *AccountQuery) Offset(n uint64) *AccountQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *AccountQuery) Where(cond kallax.Condition) *AccountQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *AccountQuery) FindByID(v ...kallax.UUID) *AccountQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Account.ID, values...))
}

// FindByType adds a new filter to the query that will require that
// the Type property is equal to the passed value.
func (q *AccountQuery) FindByType(v string) *AccountQuery {
	return q.Where(kallax.Eq(Schema.Account.Type, v))
}

// FindByRoleIdentifier adds a new filter to the query that will require that
// the RoleIdentifier property is equal to the passed value.
func (q *AccountQuery) FindByRoleIdentifier(v string) *AccountQuery {
	return q.Where(kallax.Eq(Schema.Account.RoleIdentifier, v))
}

// FindBySecret adds a new filter to the query that will require that
// the Secret property contains all the passed values; if no passed values,
// it will do nothing.
func (q *AccountQuery) FindBySecret(v ...byte) *AccountQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Account.Secret, values...))
}

// FindByPasswordHash adds a new filter to the query that will require that
// the PasswordHash property contains all the passed values; if no passed values,
// it will do nothing.
func (q *AccountQuery) FindByPasswordHash(v ...byte) *AccountQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.ArrayContains(Schema.Account.PasswordHash, values...))
}

// FindByOrganisationID adds a new filter to the query that will require that
// the OrganisationID property is equal to the passed value.
func (q *AccountQuery) FindByOrganisationID(v kallax.UUID) *AccountQuery {
	return q.Where(kallax.Eq(Schema.Account.OrganisationID, v))
}

// AccountResultSet is the set of results returned by a query to the
// database.
type AccountResultSet struct {
	ResultSet kallax.ResultSet
	last      *Account
	lastErr   error
}

// NewAccountResultSet creates a new result set for rows of the type
// Account.
func NewAccountResultSet(rs kallax.ResultSet) *AccountResultSet {
	return &AccountResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *AccountResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Account.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Account)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Account")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *AccountResultSet) Get() (*Account, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *AccountResultSet) ForEach(fn func(*Account) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *AccountResultSet) All() ([]*Account, error) {
	var result []*Account
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *AccountResultSet) One() (*Account, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *AccountResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *AccountResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewAppAccountRequestToken returns a new instance of AppAccountRequestToken.
func NewAppAccountRequestToken() (record *AppAccountRequestToken) {
	return new(AppAccountRequestToken)
}

// GetID returns the primary key of the model.
func (r *AppAccountRequestToken) GetID() kallax.Identifier {
	return (*kallax.UUID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *AppAccountRequestToken) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.UUID)(&r.ID), nil
	case "connect_token":
		return &r.ConnectToken, nil
	case "role_identifier":
		return &r.RoleIdentifier, nil
	case "expiry":
		return &r.Expiry, nil
	case "organisation_id":
		return &r.OrganisationID, nil
	case "device_label":
		return &r.DeviceLabel, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in AppAccountRequestToken: %s", col)
	}
}

// Value returns the value of the given column.
func (r *AppAccountRequestToken) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "connect_token":
		return r.ConnectToken, nil
	case "role_identifier":
		return r.RoleIdentifier, nil
	case "expiry":
		return r.Expiry, nil
	case "organisation_id":
		return r.OrganisationID, nil
	case "device_label":
		return r.DeviceLabel, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in AppAccountRequestToken: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *AppAccountRequestToken) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model AppAccountRequestToken has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *AppAccountRequestToken) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model AppAccountRequestToken has no relationships")
}

// AppAccountRequestTokenStore is the entity to access the records of the type AppAccountRequestToken
// in the database.
type AppAccountRequestTokenStore struct {
	*kallax.Store
}

// NewAppAccountRequestTokenStore creates a new instance of AppAccountRequestTokenStore
// using a SQL database.
func NewAppAccountRequestTokenStore(db *sql.DB) *AppAccountRequestTokenStore {
	return &AppAccountRequestTokenStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *AppAccountRequestTokenStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *AppAccountRequestTokenStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *AppAccountRequestTokenStore) Debug() *AppAccountRequestTokenStore {
	return &AppAccountRequestTokenStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *AppAccountRequestTokenStore) DebugWith(logger kallax.LoggerFunc) *AppAccountRequestTokenStore {
	return &AppAccountRequestTokenStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *AppAccountRequestTokenStore) DisableCacher() *AppAccountRequestTokenStore {
	return &AppAccountRequestTokenStore{s.Store.DisableCacher()}
}

// Insert inserts a AppAccountRequestToken in the database. A non-persisted object is
// required for this operation.
func (s *AppAccountRequestTokenStore) Insert(record *AppAccountRequestToken) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	record.Expiry = record.Expiry.Truncate(time.Microsecond)

	return s.Store.Insert(Schema.AppAccountRequestToken.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *AppAccountRequestTokenStore) Update(record *AppAccountRequestToken, cols ...kallax.SchemaField) (updated int64, err error) {
	record.Expiry = record.Expiry.Truncate(time.Microsecond)

	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.AppAccountRequestToken.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *AppAccountRequestTokenStore) Save(record *AppAccountRequestToken) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *AppAccountRequestTokenStore) Delete(record *AppAccountRequestToken) error {
	return s.Store.Delete(Schema.AppAccountRequestToken.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *AppAccountRequestTokenStore) Find(q *AppAccountRequestTokenQuery) (*AppAccountRequestTokenResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewAppAccountRequestTokenResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *AppAccountRequestTokenStore) MustFind(q *AppAccountRequestTokenQuery) *AppAccountRequestTokenResultSet {
	return NewAppAccountRequestTokenResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *AppAccountRequestTokenStore) Count(q *AppAccountRequestTokenQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *AppAccountRequestTokenStore) MustCount(q *AppAccountRequestTokenQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *AppAccountRequestTokenStore) FindOne(q *AppAccountRequestTokenQuery) (*AppAccountRequestToken, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *AppAccountRequestTokenStore) FindAll(q *AppAccountRequestTokenQuery) ([]*AppAccountRequestToken, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *AppAccountRequestTokenStore) MustFindOne(q *AppAccountRequestTokenQuery) *AppAccountRequestToken {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the AppAccountRequestToken with the data in the database and
// makes it writable.
func (s *AppAccountRequestTokenStore) Reload(record *AppAccountRequestToken) error {
	return s.Store.Reload(Schema.AppAccountRequestToken.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *AppAccountRequestTokenStore) Transaction(callback func(*AppAccountRequestTokenStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&AppAccountRequestTokenStore{store})
	})
}

// AppAccountRequestTokenQuery is the object used to create queries for the AppAccountRequestToken
// entity.
type AppAccountRequestTokenQuery struct {
	*kallax.BaseQuery
}

// NewAppAccountRequestTokenQuery returns a new instance of AppAccountRequestTokenQuery.
func NewAppAccountRequestTokenQuery() *AppAccountRequestTokenQuery {
	return &AppAccountRequestTokenQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.AppAccountRequestToken.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *AppAccountRequestTokenQuery) Select(columns ...kallax.SchemaField) *AppAccountRequestTokenQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *AppAccountRequestTokenQuery) SelectNot(columns ...kallax.SchemaField) *AppAccountRequestTokenQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *AppAccountRequestTokenQuery) Copy() *AppAccountRequestTokenQuery {
	return &AppAccountRequestTokenQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *AppAccountRequestTokenQuery) Order(cols ...kallax.ColumnOrder) *AppAccountRequestTokenQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *AppAccountRequestTokenQuery) BatchSize(size uint64) *AppAccountRequestTokenQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *AppAccountRequestTokenQuery) Limit(n uint64) *AppAccountRequestTokenQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *AppAccountRequestTokenQuery) Offset(n uint64) *AppAccountRequestTokenQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *AppAccountRequestTokenQuery) Where(cond kallax.Condition) *AppAccountRequestTokenQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *AppAccountRequestTokenQuery) FindByID(v ...kallax.UUID) *AppAccountRequestTokenQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.AppAccountRequestToken.ID, values...))
}

// FindByConnectToken adds a new filter to the query that will require that
// the ConnectToken property is equal to the passed value.
func (q *AppAccountRequestTokenQuery) FindByConnectToken(v string) *AppAccountRequestTokenQuery {
	return q.Where(kallax.Eq(Schema.AppAccountRequestToken.ConnectToken, v))
}

// FindByRoleIdentifier adds a new filter to the query that will require that
// the RoleIdentifier property is equal to the passed value.
func (q *AppAccountRequestTokenQuery) FindByRoleIdentifier(v string) *AppAccountRequestTokenQuery {
	return q.Where(kallax.Eq(Schema.AppAccountRequestToken.RoleIdentifier, v))
}

// FindByExpiry adds a new filter to the query that will require that
// the Expiry property is equal to the passed value.
func (q *AppAccountRequestTokenQuery) FindByExpiry(cond kallax.ScalarCond, v time.Time) *AppAccountRequestTokenQuery {
	return q.Where(cond(Schema.AppAccountRequestToken.Expiry, v))
}

// FindByOrganisationID adds a new filter to the query that will require that
// the OrganisationID property is equal to the passed value.
func (q *AppAccountRequestTokenQuery) FindByOrganisationID(v kallax.UUID) *AppAccountRequestTokenQuery {
	return q.Where(kallax.Eq(Schema.AppAccountRequestToken.OrganisationID, v))
}

// FindByDeviceLabel adds a new filter to the query that will require that
// the DeviceLabel property is equal to the passed value.
func (q *AppAccountRequestTokenQuery) FindByDeviceLabel(v string) *AppAccountRequestTokenQuery {
	return q.Where(kallax.Eq(Schema.AppAccountRequestToken.DeviceLabel, v))
}

// AppAccountRequestTokenResultSet is the set of results returned by a query to the
// database.
type AppAccountRequestTokenResultSet struct {
	ResultSet kallax.ResultSet
	last      *AppAccountRequestToken
	lastErr   error
}

// NewAppAccountRequestTokenResultSet creates a new result set for rows of the type
// AppAccountRequestToken.
func NewAppAccountRequestTokenResultSet(rs kallax.ResultSet) *AppAccountRequestTokenResultSet {
	return &AppAccountRequestTokenResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *AppAccountRequestTokenResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.AppAccountRequestToken.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*AppAccountRequestToken)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *AppAccountRequestToken")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *AppAccountRequestTokenResultSet) Get() (*AppAccountRequestToken, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *AppAccountRequestTokenResultSet) ForEach(fn func(*AppAccountRequestToken) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *AppAccountRequestTokenResultSet) All() ([]*AppAccountRequestToken, error) {
	var result []*AppAccountRequestToken
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *AppAccountRequestTokenResultSet) One() (*AppAccountRequestToken, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *AppAccountRequestTokenResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *AppAccountRequestTokenResultSet) Close() error {
	return rs.ResultSet.Close()
}

// NewOrganisation returns a new instance of Organisation.
func NewOrganisation() (record *Organisation) {
	return new(Organisation)
}

// GetID returns the primary key of the model.
func (r *Organisation) GetID() kallax.Identifier {
	return (*kallax.UUID)(&r.ID)
}

// ColumnAddress returns the pointer to the value of the given column.
func (r *Organisation) ColumnAddress(col string) (interface{}, error) {
	switch col {
	case "id":
		return (*kallax.UUID)(&r.ID), nil
	case "organisation_name":
		return &r.Name, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organisation: %s", col)
	}
}

// Value returns the value of the given column.
func (r *Organisation) Value(col string) (interface{}, error) {
	switch col {
	case "id":
		return r.ID, nil
	case "organisation_name":
		return r.Name, nil

	default:
		return nil, fmt.Errorf("kallax: invalid column in Organisation: %s", col)
	}
}

// NewRelationshipRecord returns a new record for the relatiobship in the given
// field.
func (r *Organisation) NewRelationshipRecord(field string) (kallax.Record, error) {
	return nil, fmt.Errorf("kallax: model Organisation has no relationships")
}

// SetRelationship sets the given relationship in the given field.
func (r *Organisation) SetRelationship(field string, rel interface{}) error {
	return fmt.Errorf("kallax: model Organisation has no relationships")
}

// OrganisationStore is the entity to access the records of the type Organisation
// in the database.
type OrganisationStore struct {
	*kallax.Store
}

// NewOrganisationStore creates a new instance of OrganisationStore
// using a SQL database.
func NewOrganisationStore(db *sql.DB) *OrganisationStore {
	return &OrganisationStore{kallax.NewStore(db)}
}

// GenericStore returns the generic store of this store.
func (s *OrganisationStore) GenericStore() *kallax.Store {
	return s.Store
}

// SetGenericStore changes the generic store of this store.
func (s *OrganisationStore) SetGenericStore(store *kallax.Store) {
	s.Store = store
}

// Debug returns a new store that will print all SQL statements to stdout using
// the log.Printf function.
func (s *OrganisationStore) Debug() *OrganisationStore {
	return &OrganisationStore{s.Store.Debug()}
}

// DebugWith returns a new store that will print all SQL statements using the
// given logger function.
func (s *OrganisationStore) DebugWith(logger kallax.LoggerFunc) *OrganisationStore {
	return &OrganisationStore{s.Store.DebugWith(logger)}
}

// DisableCacher turns off prepared statements, which can be useful in some scenarios.
func (s *OrganisationStore) DisableCacher() *OrganisationStore {
	return &OrganisationStore{s.Store.DisableCacher()}
}

// Insert inserts a Organisation in the database. A non-persisted object is
// required for this operation.
func (s *OrganisationStore) Insert(record *Organisation) error {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Insert(Schema.Organisation.BaseSchema, record)
}

// Update updates the given record on the database. If the columns are given,
// only these columns will be updated. Otherwise all of them will be.
// Be very careful with this, as you will have a potentially different object
// in memory but not on the database.
// Only writable records can be updated. Writable objects are those that have
// been just inserted or retrieved using a query with no custom select fields.
func (s *OrganisationStore) Update(record *Organisation, cols ...kallax.SchemaField) (updated int64, err error) {
	record.SetSaving(true)
	defer record.SetSaving(false)

	return s.Store.Update(Schema.Organisation.BaseSchema, record, cols...)
}

// Save inserts the object if the record is not persisted, otherwise it updates
// it. Same rules of Update and Insert apply depending on the case.
func (s *OrganisationStore) Save(record *Organisation) (updated bool, err error) {
	if !record.IsPersisted() {
		return false, s.Insert(record)
	}

	rowsUpdated, err := s.Update(record)
	if err != nil {
		return false, err
	}

	return rowsUpdated > 0, nil
}

// Delete removes the given record from the database.
func (s *OrganisationStore) Delete(record *Organisation) error {
	return s.Store.Delete(Schema.Organisation.BaseSchema, record)
}

// Find returns the set of results for the given query.
func (s *OrganisationStore) Find(q *OrganisationQuery) (*OrganisationResultSet, error) {
	rs, err := s.Store.Find(q)
	if err != nil {
		return nil, err
	}

	return NewOrganisationResultSet(rs), nil
}

// MustFind returns the set of results for the given query, but panics if there
// is any error.
func (s *OrganisationStore) MustFind(q *OrganisationQuery) *OrganisationResultSet {
	return NewOrganisationResultSet(s.Store.MustFind(q))
}

// Count returns the number of rows that would be retrieved with the given
// query.
func (s *OrganisationStore) Count(q *OrganisationQuery) (int64, error) {
	return s.Store.Count(q)
}

// MustCount returns the number of rows that would be retrieved with the given
// query, but panics if there is an error.
func (s *OrganisationStore) MustCount(q *OrganisationQuery) int64 {
	return s.Store.MustCount(q)
}

// FindOne returns the first row returned by the given query.
// `ErrNotFound` is returned if there are no results.
func (s *OrganisationStore) FindOne(q *OrganisationQuery) (*Organisation, error) {
	q.Limit(1)
	q.Offset(0)
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// FindAll returns a list of all the rows returned by the given query.
func (s *OrganisationStore) FindAll(q *OrganisationQuery) ([]*Organisation, error) {
	rs, err := s.Find(q)
	if err != nil {
		return nil, err
	}

	return rs.All()
}

// MustFindOne returns the first row retrieved by the given query. It panics
// if there is an error or if there are no rows.
func (s *OrganisationStore) MustFindOne(q *OrganisationQuery) *Organisation {
	record, err := s.FindOne(q)
	if err != nil {
		panic(err)
	}
	return record
}

// Reload refreshes the Organisation with the data in the database and
// makes it writable.
func (s *OrganisationStore) Reload(record *Organisation) error {
	return s.Store.Reload(Schema.Organisation.BaseSchema, record)
}

// Transaction executes the given callback in a transaction and rollbacks if
// an error is returned.
// The transaction is only open in the store passed as a parameter to the
// callback.
func (s *OrganisationStore) Transaction(callback func(*OrganisationStore) error) error {
	if callback == nil {
		return kallax.ErrInvalidTxCallback
	}

	return s.Store.Transaction(func(store *kallax.Store) error {
		return callback(&OrganisationStore{store})
	})
}

// OrganisationQuery is the object used to create queries for the Organisation
// entity.
type OrganisationQuery struct {
	*kallax.BaseQuery
}

// NewOrganisationQuery returns a new instance of OrganisationQuery.
func NewOrganisationQuery() *OrganisationQuery {
	return &OrganisationQuery{
		BaseQuery: kallax.NewBaseQuery(Schema.Organisation.BaseSchema),
	}
}

// Select adds columns to select in the query.
func (q *OrganisationQuery) Select(columns ...kallax.SchemaField) *OrganisationQuery {
	if len(columns) == 0 {
		return q
	}
	q.BaseQuery.Select(columns...)
	return q
}

// SelectNot excludes columns from being selected in the query.
func (q *OrganisationQuery) SelectNot(columns ...kallax.SchemaField) *OrganisationQuery {
	q.BaseQuery.SelectNot(columns...)
	return q
}

// Copy returns a new identical copy of the query. Remember queries are mutable
// so make a copy any time you need to reuse them.
func (q *OrganisationQuery) Copy() *OrganisationQuery {
	return &OrganisationQuery{
		BaseQuery: q.BaseQuery.Copy(),
	}
}

// Order adds order clauses to the query for the given columns.
func (q *OrganisationQuery) Order(cols ...kallax.ColumnOrder) *OrganisationQuery {
	q.BaseQuery.Order(cols...)
	return q
}

// BatchSize sets the number of items to fetch per batch when there are 1:N
// relationships selected in the query.
func (q *OrganisationQuery) BatchSize(size uint64) *OrganisationQuery {
	q.BaseQuery.BatchSize(size)
	return q
}

// Limit sets the max number of items to retrieve.
func (q *OrganisationQuery) Limit(n uint64) *OrganisationQuery {
	q.BaseQuery.Limit(n)
	return q
}

// Offset sets the number of items to skip from the result set of items.
func (q *OrganisationQuery) Offset(n uint64) *OrganisationQuery {
	q.BaseQuery.Offset(n)
	return q
}

// Where adds a condition to the query. All conditions added are concatenated
// using a logical AND.
func (q *OrganisationQuery) Where(cond kallax.Condition) *OrganisationQuery {
	q.BaseQuery.Where(cond)
	return q
}

// FindByID adds a new filter to the query that will require that
// the ID property is equal to one of the passed values; if no passed values,
// it will do nothing.
func (q *OrganisationQuery) FindByID(v ...kallax.UUID) *OrganisationQuery {
	if len(v) == 0 {
		return q
	}
	values := make([]interface{}, len(v))
	for i, val := range v {
		values[i] = val
	}
	return q.Where(kallax.In(Schema.Organisation.ID, values...))
}

// FindByName adds a new filter to the query that will require that
// the Name property is equal to the passed value.
func (q *OrganisationQuery) FindByName(v string) *OrganisationQuery {
	return q.Where(kallax.Eq(Schema.Organisation.Name, v))
}

// OrganisationResultSet is the set of results returned by a query to the
// database.
type OrganisationResultSet struct {
	ResultSet kallax.ResultSet
	last      *Organisation
	lastErr   error
}

// NewOrganisationResultSet creates a new result set for rows of the type
// Organisation.
func NewOrganisationResultSet(rs kallax.ResultSet) *OrganisationResultSet {
	return &OrganisationResultSet{ResultSet: rs}
}

// Next fetches the next item in the result set and returns true if there is
// a next item.
// The result set is closed automatically when there are no more items.
func (rs *OrganisationResultSet) Next() bool {
	if !rs.ResultSet.Next() {
		rs.lastErr = rs.ResultSet.Close()
		rs.last = nil
		return false
	}

	var record kallax.Record
	record, rs.lastErr = rs.ResultSet.Get(Schema.Organisation.BaseSchema)
	if rs.lastErr != nil {
		rs.last = nil
	} else {
		var ok bool
		rs.last, ok = record.(*Organisation)
		if !ok {
			rs.lastErr = fmt.Errorf("kallax: unable to convert record to *Organisation")
			rs.last = nil
		}
	}

	return true
}

// Get retrieves the last fetched item from the result set and the last error.
func (rs *OrganisationResultSet) Get() (*Organisation, error) {
	return rs.last, rs.lastErr
}

// ForEach iterates over the complete result set passing every record found to
// the given callback. It is possible to stop the iteration by returning
// `kallax.ErrStop` in the callback.
// Result set is always closed at the end.
func (rs *OrganisationResultSet) ForEach(fn func(*Organisation) error) error {
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return err
		}

		if err := fn(record); err != nil {
			if err == kallax.ErrStop {
				return rs.Close()
			}

			return err
		}
	}
	return nil
}

// All returns all records on the result set and closes the result set.
func (rs *OrganisationResultSet) All() ([]*Organisation, error) {
	var result []*Organisation
	for rs.Next() {
		record, err := rs.Get()
		if err != nil {
			return nil, err
		}
		result = append(result, record)
	}
	return result, nil
}

// One returns the first record on the result set and closes the result set.
func (rs *OrganisationResultSet) One() (*Organisation, error) {
	if !rs.Next() {
		return nil, kallax.ErrNotFound
	}

	record, err := rs.Get()
	if err != nil {
		return nil, err
	}

	if err := rs.Close(); err != nil {
		return nil, err
	}

	return record, nil
}

// Err returns the last error occurred.
func (rs *OrganisationResultSet) Err() error {
	return rs.lastErr
}

// Close closes the result set.
func (rs *OrganisationResultSet) Close() error {
	return rs.ResultSet.Close()
}

type schema struct {
	Account                *schemaAccount
	AppAccountRequestToken *schemaAppAccountRequestToken
	Organisation           *schemaOrganisation
}

type schemaAccount struct {
	*kallax.BaseSchema
	ID             kallax.SchemaField
	Type           kallax.SchemaField
	RoleIdentifier kallax.SchemaField
	FirstName      kallax.SchemaField
	LastName       kallax.SchemaField
	Secret         kallax.SchemaField
	EmailAddress   kallax.SchemaField
	PasswordHash   kallax.SchemaField
	DeviceToken    kallax.SchemaField
	DeviceOs       kallax.SchemaField
	OrganisationID kallax.SchemaField
	DeviceLabel    kallax.SchemaField
}

type schemaAppAccountRequestToken struct {
	*kallax.BaseSchema
	ID             kallax.SchemaField
	ConnectToken   kallax.SchemaField
	RoleIdentifier kallax.SchemaField
	Expiry         kallax.SchemaField
	OrganisationID kallax.SchemaField
	DeviceLabel    kallax.SchemaField
}

type schemaOrganisation struct {
	*kallax.BaseSchema
	ID   kallax.SchemaField
	Name kallax.SchemaField
}

var Schema = &schema{
	Account: &schemaAccount{
		BaseSchema: kallax.NewBaseSchema(
			"accounts",
			"__account",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Account)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("type"),
			kallax.NewSchemaField("role_identifier"),
			kallax.NewSchemaField("first_name"),
			kallax.NewSchemaField("last_name"),
			kallax.NewSchemaField("secret"),
			kallax.NewSchemaField("email_address"),
			kallax.NewSchemaField("password_hash"),
			kallax.NewSchemaField("device_token"),
			kallax.NewSchemaField("device_os"),
			kallax.NewSchemaField("organisation_id"),
			kallax.NewSchemaField("device_label"),
		),
		ID:             kallax.NewSchemaField("id"),
		Type:           kallax.NewSchemaField("type"),
		RoleIdentifier: kallax.NewSchemaField("role_identifier"),
		FirstName:      kallax.NewSchemaField("first_name"),
		LastName:       kallax.NewSchemaField("last_name"),
		Secret:         kallax.NewSchemaField("secret"),
		EmailAddress:   kallax.NewSchemaField("email_address"),
		PasswordHash:   kallax.NewSchemaField("password_hash"),
		DeviceToken:    kallax.NewSchemaField("device_token"),
		DeviceOs:       kallax.NewSchemaField("device_os"),
		OrganisationID: kallax.NewSchemaField("organisation_id"),
		DeviceLabel:    kallax.NewSchemaField("device_label"),
	},
	AppAccountRequestToken: &schemaAppAccountRequestToken{
		BaseSchema: kallax.NewBaseSchema(
			"app_account_request_tokens",
			"__appaccountrequesttoken",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(AppAccountRequestToken)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("connect_token"),
			kallax.NewSchemaField("role_identifier"),
			kallax.NewSchemaField("expiry"),
			kallax.NewSchemaField("organisation_id"),
			kallax.NewSchemaField("device_label"),
		),
		ID:             kallax.NewSchemaField("id"),
		ConnectToken:   kallax.NewSchemaField("connect_token"),
		RoleIdentifier: kallax.NewSchemaField("role_identifier"),
		Expiry:         kallax.NewSchemaField("expiry"),
		OrganisationID: kallax.NewSchemaField("organisation_id"),
		DeviceLabel:    kallax.NewSchemaField("device_label"),
	},
	Organisation: &schemaOrganisation{
		BaseSchema: kallax.NewBaseSchema(
			"organisations",
			"__organisation",
			kallax.NewSchemaField("id"),
			kallax.ForeignKeys{},
			func() kallax.Record {
				return new(Organisation)
			},
			false,
			kallax.NewSchemaField("id"),
			kallax.NewSchemaField("organisation_name"),
		),
		ID:   kallax.NewSchemaField("id"),
		Name: kallax.NewSchemaField("organisation_name"),
	},
}
