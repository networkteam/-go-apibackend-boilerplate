directive @bypassAuthentication on FIELD_DEFINITION

#
# Queries
#

type Query {
  "Get the current login status"
  loginStatus: Boolean! @bypassAuthentication

#  "List user accounts (global or for a specific organisation)"
#  userAccounts(organisationId: UUID, roleIdentifier: String): [UserAccount!]!
#
#  "Get user account (global or for a specific organisation)"
#  userAccount(id: UUID!, organisationId: UUID): UserAccount
#
#  "List app accounts (for a specific organisation)"
#  appAccounts(organisationId: UUID!): [AppAccount!]!
#
#  "List organisations"
#  organisations: [Organisation!]!
#
#  "List non expired app account request tokens"
#  appAccountRequestTokens(organisationId: UUID!): [AppAccountRequestToken!]!

}

#
# Domain types
#

"An organisation is a client of the system"
type Organisation {
  id: UUID!
  name: String!
}

"A user account can log in to the webapp and manage the system or organisation"
type UserAccount {
  id: UUID!
  "Email address of the user"
  emailAddress: String!
  "If no organisation is set, the user account is global"
  organisation: Organisation
  "First name of the user"
  firstName: String!
  "Last name of the user"
  lastName: String!
  "The assigned role"
  role: Role!
}

"An app account can log in via the app and is always bound to an organisation"
type AppAccount {
  "Id of the app account"
  id: UUID!
  "Organisation of the app account"
  organisation: Organisation!
  "Label of the device"
  deviceLabel: String!
  "The assigned role"
  role: Role!
}

"A request token for an app account"
type AppAccountRequestToken {
  "Id of the app account request token"
  id: UUID!
  "Token to be used to connect device"
  connectToken: String!
  "Label of the device to connect"
  deviceLabel: String!
  "When the token will expire"
  expiry: String!
}

#
# Mutations
#

type Mutation {
  "Perform a login with credentials of a user account"
  login(credentials: LoginCredentials!): LoginResult! @bypassAuthentication

  "Perform a logout of the current user account"
  logout: Error

  "Perform a login for a supervisor user (via App)"
  loginAppUser(credentials: AppUserLoginCredentials!): AppUserLoginResult! @bypassAuthentication

#  "Create a new organisation"
#  createOrganisation(input: CreateOrganisationInput!): CreateResult!
#
#  "Update an organisation"
#  updateOrganisation(input: UpdateOrganisationInput!): Result!
#
#  "Delete a new organisation"
#  deleteOrganisation(input: DeleteOrganisationInput!): Result!
#
#  "Create a new user account (global or for an organisation)"
#  createUserAccount(input: CreateUserAccountInput!): CreateResult!
#
#  "Update user account"
#  updateUserAccount(input: UpdateUserAccountInput!): Result!
#
#  "Delete user account"
#  deleteUserAccount(input: DeleteUserAccountInput!): Result!
#
#  "Create an app account for connecting a device"
#  createAppAccount(input: CreateAppAccountInput!): CreateAppAccountResult!
#
#  "Redeem a connect token for an app account to get an auth token"
#  redeemAppAccount(input: RedeemAppAccountInput!): RedeemAppAccountResult! @bypassAuthentication
#
#  "Delete app account"
#  deleteAppAccount(input: DeleteAppAccountInput!): Result!
#
#  "Disconnect app account"
#  disconnectAppAccount(input: DisconnectAppAccountInput!): Result!
}

"Login credentials for user accounts"
input LoginCredentials {
  "Email address of the user account"
  emailAddress: String!
  "Password of the user account"
  password: String!
}

"Login credentials for app user accounts"
input AppUserLoginCredentials {
  "Email address of the user account"
  emailAddress: String!
  "Password of the user account"
  password: String!
  "A device token"
  deviceToken: String
  "The Device OS (IOS or Android)"
  deviceOs: String
}

input RedeemAppAccountInput {
  connectToken: String!
  "A device token"
  deviceToken: String
  "The Device OS (IOS or Android)"
  deviceOs: String
}

"Login result"
type LoginResult {
  "The authenticated account (if error is null)"
  account: UserAccount!
  "The organisation of the authenticated account (global if empty)"
  organisation: Organisation
  "CSRF token to be sent in subsequent requests (if error is null)"
  csrfToken: String!
  "An error if authentication failed"
  error: Error
}

input CreateOrganisationInput {
  "Name of the organisation to be created (must be unique)"
  name: String!
}

input UpdateOrganisationInput {
  "Organisation id to update"
  id: UUID!
  "Name of the organisation (must be unique)"
  name: String!
}

input DeleteOrganisationInput {
  "ID of organisation to delete"
  organisationId: UUID!
}

input CreateUserAccountInput {
  "Organisation id of the new user account (global if empty)"
  organisationId: UUID
  "Email address of the user account to create (must be unique)"
  emailAddress: String!
  "Password of the user account to create (minimum length: 8 characters)"
  password: String!
  "A first name for the user account"
  firstName: String!
  "A last name for the user account"
  lastName: String!
  "Role of the user account to create"
  role: Role!
}

input UpdateUserAccountInput {
  "User account id to update"
  id: UUID!
  "Organisation id of the user account (must match user account, empty for system administrator)"
  organisationId: UUID
  "Email address of the user account to create (must be unique)"
  emailAddress: String!
  "Password of the user account (minimum length: 8 characters), omit to keep existing password"
  password: String
  "A first name for the user account"
  firstName: String!
  "A last name for the user account"
  lastName: String!
  "Role of the user account"
  role: Role!
}

input CreateAppAccountInput {
  "Organisation id of the app account"
  organisationId: UUID!
  "A label for the device"
  deviceLabel: String!
  "Role of the app account to create"
  role: Role!
}

input DeleteAppAccountInput {
  id: UUID!
  "Organisation id of the app account (must match app account)"
  organisationId: UUID!
}

input DisconnectAppAccountInput {
  id: UUID!
  "Organisation id of the app account (must match app account)"
  organisationId: UUID!
}

input DeleteUserAccountInput {
  id: UUID!
  "Organisation id of the user account (must match user account, or empty for systemadministrator)"
  organisationId: UUID
}

"Create app account result"
type CreateAppAccountResult {
  "Id of the created resource (if error is null)"
  id: UUID!
  "Token for connecting the device (if error is null)"
  connectToken: String!
  "An error if creation failed"
  error: FieldsError
}

"App user account result"
type AppUserLoginResult {
  "The authenticated account (if error is null)"
  account: UserAccount!
  "The organisation of the authenticated account (if error is null)"
  organisation: Organisation!
  "Auth token to be sent in subsequent requests (if error is null)"
  authToken: String!
  "An error if the operation failed"
  error: Error
}

"Redeem app account result"
type RedeemAppAccountResult {
  "The authenticated account (if error is null)"
  account: AppAccount!
  "The organisation of the authenticated account (if error is null)"
  organisation: Organisation!
  "Auth token to be sent in subsequent requests (if error is null)"
  authToken: String!
  "An error if the operation failed"
  error: Error
}

#
# Common types
#

"Generic creation result"
type CreateResult {
  "Id of the created resource (if error is null)"
  id: UUID!
  "An error if creation failed"
  error: FieldsError
}

"Generic result"
type Result {
  "An error if the operation failed"
  error: FieldsError
}

"A UUID is used for identifiers of most resources, should be treated as an opaque string"
scalar UUID

"A DateTime is used for date times"
scalar DateTime

"Possible roles of accounts"
enum Role {
  SystemAdministrator
  OrganisationAdministrator
  User
  App
}

"An error with information about fields"
type FieldsError {
  "List of errors specific to a field (or global)"
  errors: [FieldError!]!
}

"A generic field based error"
type FieldError {
  "A path to the field where the error occured, empty array if the error is not bound to a specific field"
  path: [String!]!
  "An error code that can be translated in the client"
  code: String!
  "Arguments for translation of the code"
  arguments: [String!]!
}

"A generic application error (for expected errors)"
type Error {
  "An error code that can be translated in the client"
  code: String!
  "Arguments for translation of the code"
  arguments: [String!]!
}

"Paged query paramaters"
input PagedQueryParameters {
  "Optional limit for max number of results"
  limit: Int
  "Optional result id to always start after the given result (for stable fetch more)"
  afterResultId: UUID
}
